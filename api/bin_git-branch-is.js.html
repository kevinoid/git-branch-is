<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: bin/git-branch-is.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: bin/git-branch-is.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>#!/usr/bin/env node
/**
 * @copyright Copyright 2016 Kevin Locke &lt;kevin@kevinlocke.name>
 * @license MIT
 */

'use strict';

const { Command } = require('commander');

const gitBranchIs = require('..');
const packageJson = require('../package.json');

function collect(arg, args) {
  args.push(arg);
  return args;
}

/** Result from command entry points.
 *
 * @typedef {{
 *   code: (?number|undefined),
 *   stdout: (?string|undefined),
 *   stderr: (?string|undefined)
 * }} CommandResult
 * @property {?number=} code Exit code for the command.
 * @property {?string=} stdout Content to write to stdout.
 * @property {?string=} stderr Content to write to stderr.
 */

/**
 * Entry point for this command.
 *
 * @param {!Array&lt;string>} args Command-line arguments.
 * @param {?function(Error, ?CommandResult=)=} callback Callback for the
 * command result or error.  Required if &lt;code>global.Promise&lt;/code> is not
 * defined.
 * @returns {Promise|undefined} If &lt;code>callback&lt;/code> is not given and
 * &lt;code>global.Promise&lt;/code> is defined, a &lt;code>Promise&lt;/code> which will
 * resolve on completion.
 */
function gitBranchIsCmd(args, callback) {
  if (!callback &amp;&amp; typeof Promise === 'function') {
    return new Promise((resolve, reject) => {
      gitBranchIsCmd(args, (err, result) => {
        if (err) { reject(err); } else { resolve(result); }
      });
    });
  }

  if (typeof callback !== 'function') {
    throw new TypeError('callback must be a function');
  }

  // TODO:  Proxy console.{error,log} and process.exit so we can return result
  const command = new Command()
    .arguments('&lt;branch_name>')
    .option('-C &lt;path>', 'run as if started in &lt;path>')
    .option(
      '--git-arg &lt;arg>', 'additional argument to git (can be repeated)',
      collect, [],
    )
    .option('--git-dir &lt;dir>', 'set the path to the repository')
    .option('--git-path &lt;path>', 'set the path to the git binary')
    .option('-i, --ignore-case', 'compare/match branch_name case-insensitively')
    .option('-I, --invert-match', 'inverts/negates comparison')
    // Note:  Commander.js only supports one long option per option call
    // https://github.com/tj/commander.js/issues/430
    .option('--not', 'inverts/negates comparison (same as --invert-match)')
    .option('-q, --quiet', 'suppress warning message if branch differs')
    .option('-r, --regex', 'match branch_name as a regular expression')
    .option('-v, --verbose', 'print a message if the branch matches')
    .version(packageJson.version)
    .parse(args);

  if (command.args.length !== 1) {
    callback(new Error(`Exactly one argument is required.\n${
      command.helpInformation()}`));
    return undefined;
  }

  // -C option is cmd in options Object
  command.cwd = command.C;

  // pluralize --git-arg to cover multiple uses
  command.gitArgs = command.gitArg;

  // treat --not as an alias for --invert-match
  command.invertMatch = command.invertMatch || command.not;

  const expectedBranch = command.args[0];

  let expectedBranchRegExp;
  if (command.regex) {
    try {
      expectedBranchRegExp = new RegExp(
        expectedBranch,
        command.ignoreCase ? 'i' : undefined,
      );
    } catch (errRegExp) {
      // Benefit of avoiding unnecessary API changes outweighs style concerns
      // eslint-disable-next-line unicorn/no-null
      callback(null, {
        code: 2,
        stderr: `Error: Invalid RegExp "${expectedBranch}": ${
          errRegExp}\n`,
      });
      return undefined;
    }
  }

  gitBranchIs.getBranch(command, (err, currentBranch) => {
    if (err) {
      callback(err);
      return;
    }

    let errMsg, isMatch;
    if (expectedBranchRegExp) {
      isMatch = expectedBranchRegExp.test(currentBranch);
      if (command.invertMatch) {
        isMatch = !isMatch;
      }

      if (!isMatch &amp;&amp; !command.quiet) {
        errMsg = command.invertMatch
          ? `Current branch "${currentBranch}" matches "${expectedBranch}".\n`
          : `Current branch "${currentBranch}" does not match "${
            expectedBranch}".\n`;
      }
    } else {
      isMatch = currentBranch === expectedBranch
        || (command.ignoreCase
            &amp;&amp; currentBranch.toUpperCase() === expectedBranch.toUpperCase());
      if (command.invertMatch) {
        isMatch = !isMatch;
      }

      if (!isMatch &amp;&amp; !command.quiet) {
        errMsg = command.invertMatch
          ? `Current branch is "${currentBranch}".\n`
          : `Current branch is "${currentBranch}", not "${expectedBranch}".\n`;
      }
    }

    // Benefit of avoiding unnecessary API changes outweighs style concerns
    // eslint-disable-next-line unicorn/no-null
    callback(null, {
      code: isMatch ? 0 : 1,
      stderr: errMsg &amp;&amp; `Error: ${errMsg}`,
      stdout: isMatch &amp;&amp; command.verbose
        ? `Current branch is "${currentBranch}".\n`
        : null, // eslint-disable-line unicorn/no-null
    });
  });
  return undefined;
}

module.exports = gitBranchIsCmd;

if (require.main === module) {
  // This file was invoked directly.
  /* eslint-disable no-process-exit */
  gitBranchIsCmd(process.argv, (err, result) => {
    const errOrResult = err || result;
    if (errOrResult.stdout) { process.stdout.write(errOrResult.stdout); }
    if (errOrResult.stderr) { process.stderr.write(errOrResult.stderr); }
    if (err) { process.stderr.write(`${err.name}: ${err.message}\n`); }

    const code = typeof errOrResult.code === 'number' ? errOrResult.code
      : err ? 1 : 0;
    process.exit(code);
  });
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#gitBranchIs">gitBranchIs</a></li><li><a href="global.html#gitBranchIsCmd">gitBranchIsCmd</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.5</a> on Fri Jul 31 2020 17:27:29 GMT-0600 (Mountain Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
